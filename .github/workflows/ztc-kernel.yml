name: Melt Kernel Build with SukiSU
permissions:
  contents: write
  actions: write

on:
  workflow_dispatch:

jobs:
  build-kernel-sukisu-susfs:
    runs-on: ubuntu-latest
    env:
      CCACHE_COMPILERCHECK: "%compiler% -dumpmachine; %compiler% -dumpversion"
      CCACHE_NOHASHDIR: "true"
      CCACHE_HARDLINK: "true"

    steps:
      - name: Maximize Build Space
        uses: AdityaGarg8/remove-unwanted-software@v5
        with:
          remove-dotnet: 'true'
          remove-android: 'true'
          remove-haskell: 'true'
          remove-codeql: 'true'
          remove-docker-images: 'true'
          remove-large-packages: 'true'
          remove-swapfile: 'true'
          remove-cached-tools: 'false'
          verbose: 'true'

      - name: 设定 CONFIG 环境变量
        run: |
          CONFIG="android12-5.10-lts"
          echo "CONFIG=$CONFIG" >> $GITHUB_ENV
          echo "CONFIG set to: $CONFIG"

      - name: 安装依赖
        run: |
          sudo apt update && sudo apt upgrade -y
          sudo apt install -y ccache python3 git curl build-essential libssl-dev bison flex libelf-dev dwarves dos2unix file wget

      - name: 配置 ccache
        run: |
          mkdir -p ~/.ccache
          ccache --version
          ccache --max-size=2G
          ccache --set-config=compression=true
          echo "CCACHE_DIR=$HOME/.ccache" >> $GITHUB_ENV

      - name: 配置 Git
        run: |
          git config --global user.name "zzh20188"
          git config --global user.email "BuildGkiKernel@gmail.com"
      
      - name: 安装仓库工具
        run: |
          mkdir -p ./git-repo
          curl -s https://storage.googleapis.com/git-repo-downloads/repo > ./git-repo/repo
          chmod a+rx ./git-repo/repo
          echo "REPO_PATH=$GITHUB_WORKSPACE/git-repo" >> $GITHUB_ENV

      - name: 克隆 AnyKernel3
        run: |
          echo "Cloning AnyKernel3..."
          ANYKERNEL_BRANCH="gki-2.0"
          if [ ! -d "AnyKernel3" ]; then
            git clone https://github.com/WildPlusKernel/AnyKernel3.git -b "$ANYKERNEL_BRANCH"
          else
            echo "AnyKernel3 already exists"
          fi

      - name: 克隆 Melt Kernel 源码
        run: |
          echo "Cloning Melt Kernel source..."
          echo "当前工作目录: $(pwd)"
          echo "CONFIG: $CONFIG"
          
          # 清理并创建目录
          if [ -d "$CONFIG" ]; then
            echo "删除已存在的 $CONFIG 目录"
            rm -rf "$CONFIG"
          fi
          
          mkdir -p "$CONFIG"
          cd "$CONFIG"
          echo "进入目录: $(pwd)"
          
          # 克隆 Melt Kernel 源码
          git clone https://github.com/Pzqqt/android_kernel_xiaomi_marble.git --depth=1 --branch melt-rebase .
          
          # 验证克隆结果
          if [ -d ".git" ]; then
            echo "✅ 内核源码克隆成功"
            echo "Git 仓库信息:"
            git log --oneline -5
          else
            echo "❌ 内核源码克隆失败"
            exit 1
          fi
          
          # 设置构建环境变量
          KERNEL_SOURCE="$GITHUB_WORKSPACE/$CONFIG"
          echo "KERNEL_SOURCE=$KERNEL_SOURCE" >> $GITHUB_ENV
          echo "内核源码路径: $KERNEL_SOURCE"

      - name: 验证内核源码目录
        run: |
          echo "验证内核源码目录..."
          echo "当前工作目录: $(pwd)"
          echo "CONFIG: $CONFIG"
          
          if [ ! -d "$CONFIG" ]; then
            echo "❌ 错误: 目录 $CONFIG 不存在"
            echo "当前目录内容:"
            ls -la
            exit 1
          fi
          
          echo "✅ 目录 $CONFIG 存在"
          echo "目录内容:"
          ls -la "$CONFIG/"
          
          # 检查关键文件
          cd "$CONFIG"
          echo "内核源码关键文件检查:"
          ls -la Makefile 2>/dev/null && echo "✅ Makefile 存在" || echo "❌ Makefile 不存在"
          ls -la arch/arm64/configs/gki_defconfig 2>/dev/null && echo "✅ gki_defconfig 存在" || echo "❌ gki_defconfig 不存在"

      - name: 获取 SukiSU & SUSFS 版本
        id: get_versions
        run: |
          echo "获取 SukiSU 和 SUSFS 版本信息..."
          
          # 计算SukiSU版本号
          if [ ! -d "KernelSU-temp" ]; then
            git clone https://github.com/SukiSU-Ultra/SukiSU-Ultra.git KernelSU-temp --depth=1
          fi
          
          cd KernelSU-temp
          KSU_GIT_VERSION=$(git rev-list --count HEAD)
          KSU_VERSION=$((40000 + KSU_GIT_VERSION - 2815))
          echo "SukiSU Version: $KSU_VERSION"
          echo "KSU_VERSION=$KSU_VERSION" >> $GITHUB_ENV
          
          # 计算SUSFS版本号
          INFO="https://gitlab.com/simonpunk/susfs4ksu/-/raw/gki-android12-5.10/ksu_module_susfs/module.prop?ref_type=heads"
          SUS_VERSION=$(curl -s "$INFO" | awk -F '=' '$1 == "version" { print $2 }' | tr -d '[:space:]' || echo "v1.5.12")
          echo "SUSFS Version: $SUS_VERSION"
          echo "SUS_VERSION=$SUS_VERSION" >> $GITHUB_ENV
          
          echo "kversion=$KSU_VERSION" >> $GITHUB_OUTPUT
          echo "sversion=$SUS_VERSION" >> $GITHUB_OUTPUT
          
          # 清理临时目录
          cd ..
          rm -rf KernelSU-temp

      - name: 应用 SukiSU 补丁
        run: |
          echo "应用 SukiSU 补丁..."
          echo "当前工作目录: $(pwd)"
          
          if [ ! -d "$CONFIG" ]; then
            echo "❌ 错误: 内核源码目录不存在"
            exit 1
          fi
          
          cd "$CONFIG"
          echo "现在位于内核源码目录: $(pwd)"
          
          # 克隆 SukiSU
          if [ ! -d "KernelSU" ]; then
            echo "克隆 SukiSU..."
            git clone https://github.com/SukiSU-Ultra/SukiSU-Ultra.git KernelSU --depth=1
          else
            echo "KernelSU 已存在，跳过克隆"
          fi
          
          # 检查并应用补丁
          if [ -f "KernelSU/kernel.patch" ]; then
            echo "应用 SukiSU kernel.patch..."
            # 检查补丁文件格式
            file KernelSU/kernel.patch
            # 应用补丁
            patch -p1 --verbose < KernelSU/kernel.patch || echo "补丁应用完成或无需应用"
          else
            echo "未找到 kernel.patch，检查 KernelSU 目录内容:"
            ls -la KernelSU/ 2>/dev/null || echo "无法访问 KernelSU 目录"
            echo "跳过 SukiSU 补丁应用"
          fi

      - name: 应用 SUSFS 补丁
        run: |
          echo "应用 SUSFS 补丁..."
          cd "$CONFIG"
          echo "当前目录: $(pwd)"
          
          branch="gki-android12-5.10"
          echo "使用分支: $branch"
          
          # 创建补丁目录
          mkdir -p susfs_patches
          
          # 下载 SUSFS 补丁文件
          echo "下载 SUSFS 补丁文件..."
          
          # 下载 KernelSU 集成补丁
          curl -L -o "susfs_patches/10_enable_susfs_for_ksu.patch" \
            "https://gitlab.com/simonpunk/susfs4ksu/-/raw/$branch/kernel_patches/KernelSU/10_enable_susfs_for_ksu.patch?ref_type=heads" || \
            echo "下载 10_enable_susfs_for_ksu.patch 失败"
          
          # 下载主内核补丁
          curl -L -o "susfs_patches/50_add_susfs.patch" \
            "https://gitlab.com/simonpunk/susfs4ksu/-/raw/$branch/kernel_patches/50_add_susfs_in_$branch.patch?ref_type=heads" || \
            echo "下载 50_add_susfs.patch 失败"
          
          # 检查下载的文件
          echo "下载的补丁文件:"
          ls -la susfs_patches/ 2>/dev/null || echo "susfs_patches 目录不存在"
          
          # 应用 SUSFS 补丁
          if [ -f "susfs_patches/10_enable_susfs_for_ksu.patch" ]; then
            echo "应用 10_enable_susfs_for_ksu.patch..."
            patch -p1 --verbose < "susfs_patches/10_enable_susfs_for_ksu.patch" || \
            echo "SUSFS for KSU 补丁可能已应用或存在冲突"
          fi
          
          if [ -f "susfs_patches/50_add_susfs.patch" ]; then
            echo "应用 50_add_susfs.patch..."
            patch -p1 --verbose < "susfs_patches/50_add_susfs.patch" || \
            echo "SUSFS 内核补丁可能已应用或存在冲突"
          fi

      - name: 配置内核功能
        run: |
          echo "配置内核功能..."
          cd "$CONFIG"
          
          # 备份原始配置
          cp arch/arm64/configs/gki_defconfig arch/arm64/configs/gki_defconfig.backup
          
          # 配置 SukiSU 相关选项
          echo "添加 SukiSU 配置..."
          echo "CONFIG_KPROBES=y" >> arch/arm64/configs/gki_defconfig
          echo "CONFIG_HAVE_KPROBES=y" >> arch/arm64/configs/gki_defconfig
          echo "CONFIG_KPROBE_EVENTS=y" >> arch/arm64/configs/gki_defconfig
          echo "CONFIG_OVERLAY_FS=y" >> arch/arm64/configs/gki_defconfig
          
          # 配置 SUSFS
          echo "添加 SUSFS 配置..."
          echo "CONFIG_SUSFS=y" >> arch/arm64/configs/gki_defconfig
          echo "CONFIG_KSU=y" >> arch/arm64/configs/gki_defconfig
          
          # 配置 KPM
          echo "添加 KPM 配置..."
          echo "CONFIG_KPM=y" >> arch/arm64/configs/gki_defconfig
          echo "CONFIG_KPM_DEBUG=y" >> arch/arm64/configs/gki_defconfig
          
          # 配置 ZRAM
          echo "添加 ZRAM 配置..."
          echo "CONFIG_ZRAM=y" >> arch/arm64/configs/gki_defconfig
          echo "CONFIG_ZRAM_WRITEBACK=y" >> arch/arm64/configs/gki_defconfig
          echo "CONFIG_ZSMALLOC=y" >> arch/arm64/configs/gki_defconfig
          echo "CONFIG_CRYPTO_LZ4=y" >> arch/arm64/configs/gki_defconfig
          echo "CONFIG_CRYPTO_LZ4HC=y" >> arch/arm64/configs/gki_defconfig
          echo "CONFIG_CRYPTO_LZO=y" >> arch/arm64/configs/gki_defconfig
          echo "CONFIG_CRYPTO_ZSTD=y" >> arch/arm64/configs/gki_defconfig
          
          echo "配置完成，显示添加的配置行:"
          tail -20 arch/arm64/configs/gki_defconfig

      - name: 检查内核源码结构
        run: |
          echo "检查内核源码目录结构..."
          cd "$CONFIG"
          echo "当前目录: $(pwd)"
          echo "目录内容:"
          ls -la
          echo "查找构建脚本:"
          find . -name "build.sh" -type f
          find . -name "build*.sh" -type f
          echo "build 目录内容:"
          ls -la build/ 2>/dev/null || echo "没有 build 目录"

      - name: 配置构建环境
        run: |
          echo "配置构建环境..."
          cd "$CONFIG"
          
          # 检查并设置构建脚本权限
          if [ -f "build.sh" ]; then
            chmod +x build.sh
            dos2unix build.sh 2>/dev/null || echo "dos2unix 不可用或不需要"
            echo "✅ 设置 build.sh 执行权限"
          fi
          
          if [ -f "build/build.sh" ]; then
            chmod +x build/build.sh
            dos2unix build/build.sh 2>/dev/null || echo "dos2unix 不可用或不需要"
            echo "✅ 设置 build/build.sh 执行权限"
          fi
          
          # 下载编译工具链
          echo "下载 Clang 工具链..."
          if [ ! -d "prebuilts/clang/host/linux-x86/clang-r563880" ]; then
            curl -LSs "https://github.com/zzh20188/ZTC-Kenel-Build/releases/download/clang/clang-r563880.tar.gz" -o clang-r563880.tar.gz
            mkdir -p prebuilts/clang/host/linux-x86/clang-r563880
            tar -xzf clang-r563880.tar.gz -C prebuilts/clang/host/linux-x86/clang-r563880
            rm -f clang-r563880.tar.gz
          else
            echo "Clang 工具链已存在"
          fi
          
          # 验证工具链
          if [ -f "prebuilts/clang/host/linux-x86/clang-r563880/bin/clang" ]; then
            echo "✅ Clang 工具链验证成功"
          else
            echo "❌ Clang 工具链验证失败"
          fi

      - name: 构建内核
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 90
          max_attempts: 3
          retry_on: timeout
          command: |
            set -e
            set -x
            cd "$CONFIG"
            echo "构建 Melt Kernel with SukiSU and SUSFS..."
            echo "当前工作目录: $(pwd)"
            echo "目录内容:"
            ls -la
            
            # 设置构建环境
            export PATH="$PWD/prebuilts/clang/host/linux-x86/clang-r563880/bin:$PATH"
            export ARCH=arm64
            export CROSS_COMPILE=aarch64-linux-gnu-
            
            # 检查构建系统
            if [ -f "build/build.sh" ]; then
                echo "使用 build/build.sh 构建系统"
                chmod +x build/build.sh
                LTO=thin KCFLAGS="-O3" BUILD_CONFIG=build.config.gki.aarch64 ./build/build.sh CC=clang || exit 1
            elif [ -f "build.sh" ]; then
                echo "使用根目录的 build.sh 构建系统"
                chmod +x build.sh
                LTO=thin KCFLAGS="-O3" BUILD_CONFIG=build.config.gki.aarch64 ./build.sh CC=clang || exit 1
            elif [ -f "Makefile" ]; then
                echo "使用传统 Makefile 构建系统"
                # 尝试传统内核构建方式
                make gki_defconfig ARCH=arm64 CC=clang || exit 1
                make -j$(nproc) ARCH=arm64 CC=clang || exit 1
            else
                echo "❌ 错误: 未找到构建系统"
                find . -name "*.sh" -type f
                find . -name "Makefile" -type f
                exit 1
            fi

      - name: 创建Boot镜像
        run: |
          echo "创建 Boot 镜像..."
          mkdir -p bootimgs
          
          # 查找并复制生成的镜像文件
          if [ -d "./$CONFIG/out" ]; then
            echo "在 out 目录中查找镜像文件..."
            find "./$CONFIG/out" -name "Image" -exec cp -v {} ./bootimgs/ \; || echo "Image 复制失败"
            find "./$CONFIG/out" -name "Image.lz4" -exec cp -v {} ./bootimgs/ \; || echo "Image.lz4 复制失败"
            find "./$CONFIG/out" -name "Image" -exec cp -v {} ./ \; || echo "Image 复制到根目录失败"
            find "./$CONFIG/out" -name "Image.lz4" -exec cp -v {} ./ \; || echo "Image.lz4 复制到根目录失败"
          fi
          
          # 检查 arch/arm64/boot 目录（传统构建位置）
          if [ -d "./$CONFIG/arch/arm64/boot" ]; then
            echo "在 arch/arm64/boot 中查找镜像文件..."
            cp -v "./$CONFIG/arch/arm64/boot/Image" ./bootimgs/ 2>/dev/null || echo "传统位置 Image 复制失败"
            cp -v "./$CONFIG/arch/arm64/boot/Image" ./ 2>/dev/null || echo "传统位置 Image 复制到根目录失败"
          fi
          
          # 创建 gzip 压缩版本
          if [ -f "./Image" ]; then
            echo "创建 Image.gz..."
            gzip -n -k -f -9 ./Image && cp ./Image.gz ./bootimgs/ || echo "Gzip 压缩失败"
          fi
          
          echo "生成的镜像文件:"
          ls -la ./bootimgs/ 2>/dev/null || echo "bootimgs 目录为空"

      - name: 准备AnyKernel3
        run: |
          echo "准备 AnyKernel3..."
          if [ -f "./Image" ]; then
            cp -v ./Image ./AnyKernel3/Image || echo "复制 Image 到 AnyKernel3 失败"
          elif [ -f "./bootimgs/Image" ]; then
            cp -v ./bootimgs/Image ./AnyKernel3/Image || echo "从 bootimgs 复制 Image 失败"
          else
            echo "❌ 错误: 未找到 Image 文件"
            echo "当前目录内容:"
            ls -la ./
            echo "bootimgs 目录内容:"
            ls -la ./bootimgs/ 2>/dev/null || echo "bootimgs 目录不存在"
          fi

      - name: 添加 SukiSU 管理器
        id: add_sukisu
        continue-on-error: true
        run: |
          echo "添加 SukiSU 管理器..."
          REPO="SukiSU-Ultra/SukiSU-Ultra"
          
          # 尝试获取最新的构建
          ARTIFACTS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/$REPO/actions/artifacts?per_page=10")
          
          MANAGER_URL=$(echo "$ARTIFACTS" | jq -r '.artifacts[] | select(.name | contains("manager")) | .archive_download_url' | head -1)
          
          if [ -n "$MANAGER_URL" ] && [ "$MANAGER_URL" != "null" ]; then
            echo "下载 SukiSU 管理器: $MANAGER_URL"
            curl -L -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -o "SukiSU-Manager-${{ env.KSU_VERSION }}.zip" "$MANAGER_URL"
            
            if [ -f "SukiSU-Manager-${{ env.KSU_VERSION }}.zip" ]; then
              unzip -o "SukiSU-Manager-${{ env.KSU_VERSION }}.zip" || echo "解压失败或无文件可提取"
              rm -f "SukiSU-Manager-${{ env.KSU_VERSION }}.zip"
              echo "✅ SukiSU 管理器下载成功"
            else
              echo "❌ SukiSU 管理器下载失败"
            fi
          else
            echo "⚠️ 未找到 SukiSU 管理器，跳过"
          fi

      - name: 添加 SUSFS 模块
        id: add_SUSFS
        continue-on-error: true
        run: |
          echo "添加 SUSFS 模块..."
          # 简化 SUSFS 模块下载逻辑
          echo "⚠️ SUSFS 模块下载功能待实现，跳过此步骤"

      - name: 上传编译资产
        uses: actions/upload-artifact@v4
        with:
          name: Melt-SukiSU-Build-${{ env.KSU_VERSION }}
          path: |
            ./AnyKernel3/
            ./*.apk
            ./bootimgs/
          retention-days: 7

      - name: 创建发布版本
        if: success()
        run: |
          echo "✅ 构建完成成功!"
          echo "SukiSU 版本: ${{ env.KSU_VERSION }}"
          echo "SUSFS 版本: ${{ env.SUS_VERSION }}"
          echo "内核源码: Melt Kernel (Pzqqt/android_kernel_xiaomi_marble)"
          echo "构建时间: $(date)"
